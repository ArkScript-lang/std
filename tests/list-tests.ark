(import std.List)
(import std.Math :even?)
(import std.Testing)

(let a [1 2 3])
(let b [4 5 6])
(let zipped [[1 5] [2 6] [3 7] [4 8]])
(let reversedZipped [[4 8] [3 7] [2 6] [1 5]])

(test:suite list {
  (test:case "builtins" {
    (test:eq (builtin__list:reverse a) (list:reverse a))
    (test:eq (builtin__list:reverse []) (list:reverse []))

    (test:eq (builtin__list:find a 0) (list:find a 0))
    (test:eq (builtin__list:find a 1) (list:find a 1))

    (test:eq (builtin__list:slice a 1 2 1) (list:slice a 1 2 1))

    (test:eq (builtin__list:sort [9 8 1]) (list:sort [9 8 1]))
    (test:eq (builtin__list:sort []) (list:sort []))

    (test:eq (builtin__list:fill 5 nil) (list:fill 5 nil))

    (test:eq (builtin__list:setAt a 0 5) (list:setAt a 0 5)) })

  (test:case "contains?" {
    (test:expect (list:contains? [1 2 3] 1))
    (test:expect (not (list:contains? [1 2 3] "1")))
    (test:expect (list:contains? ["1" "2" "3"] "1")) })

  (test:case "size" {
    (test:eq (list:size []) 0)
    (test:eq (list:size [1 2 3]) 3) })

  (test:case "forEach" {
    (list:forEach a (fun (e) {
      # just assert we have something, basically it's just a while + @
      (test:neq e nil) })) })

  (test:case "enumerate" {
    (mut position 0)
    (list:enumerate a (fun (idx e) {
      (test:eq idx position)
      (set position (+ 1 position))
      # just assert we have something, basically it's just a while + @
      (test:eq (type e) "Number") })) })

  (test:case "product" {
    (test:eq (list:product b) (* 4 5 6))
    (test:eq (list:product []) 1) })

  (test:case "sum" {
    (test:eq (list:sum b) (+ 4 5 6))
    (test:eq (list:sum []) 0) })

  (test:case "min" {
    (test:eq (list:min []) nil)
    (test:eq (list:min b) 4)
    (test:eq (list:min [-1]) -1) })

  (test:case "max" {
    (test:eq (list:max []) nil)
    (test:eq (list:max b) 6)
    (test:eq (list:max [-1]) -1) })

  (test:case "median" {
    (test:eq (list:median []) nil)
    (test:eq (list:median [1]) 1)
    (test:eq (list:median [1 2]) 1.5)
    (test:eq (list:median [2 1 3]) 2)
    (test:eq (list:median [1 2 2 1]) 1.5)
    (test:eq (list:median [1 2 2 1 3]) 2) })

  (test:case "drop" {
    (test:eq (list:drop a 0) [1 2 3])
    (test:eq (list:drop a 1) [2 3])
    (test:eq (list:drop a 2) [3]) })

  (test:case "dropWhile" {
    (test:eq (list:dropWhile a (fun (c) (< c 0))) [1 2 3])
    (test:eq (list:dropWhile a (fun (c) (< c 2))) [2 3])
    (test:eq (list:dropWhile a (fun (c) (< c 5))) []) })

  (test:case "filter" {
    (test:eq (list:filter a math:even?) [2])
    (test:eq (list:filter a (fun (e) (> e 100))) [])
    (test:eq (list:filter [] (fun (e) (> e 100))) []) })

  (test:case "sortByKey" {
    (test:eq (list:sortByKey reversedZipped (fun (e) (head e))) zipped)
    (test:eq (list:sortByKey [9 8 1] (fun (e) e)) [1 8 9])
    (test:eq (list:sortByKey [] (fun (e) e)) []) })

  (test:case "map" {
    (test:eq (list:map b (fun (e) (* e e))) [16 25 36])
    (test:eq (list:map [] (fun (e) (* e e))) []) })

  (test:case "reduce" {
    (test:eq (list:reduce a (fun (x y) (- x y))) -4) })

  (test:case "flatten" {
    (test:eq (list:flatten []) [])
    (test:eq (list:flatten [[]]) [])
    (test:eq (list:flatten [[1]]) [1])
    (test:eq (list:flatten zipped) [1 5 2 6 3 7 4 8]) })

  (test:case "flatMap" {
    (test:eq (list:flatMap [] (fun (a) [a a])) [])
    (test:eq (list:flatMap a (fun (a) (* 2 a))) [2 4 6])
    (test:eq (list:flatMap a (fun (a) [a a])) [1 1 2 2 3 3]) })

  (test:case "take" {
    (test:eq (list:take a 1) [1])
    (test:eq (list:take a 100) a) })

  (test:case "takeWhile" {
    (test:eq (list:takeWhile a (fun (c) (< c 0))) [])
    (test:eq (list:takeWhile a (fun (c) (< c 2))) [1])
    (test:eq (list:takeWhile a (fun (c) (< c 3))) [1 2])
    (test:eq (list:takeWhile a (fun (c) (< c 5))) [1 2 3]) })

  (test:case "partition" {
    (test:eq (list:partition a (fun (c i) (= 0 (mod c 2)))) [[2] [1 3]])
    (test:eq (list:partition a (fun (c i) (= 0 c))) [[] [1 2 3]])
    (test:eq (list:partition [] (fun (c i) (= 0 c))) [[] []]) })

  (test:case "unzip" {
    (test:eq (list:unzip zipped) [[1 2 3 4] [5 6 7 8]])
    (test:eq (list:unzip []) [[] []]) })

  (test:case "zip" {
    (test:eq (list:zip a b) [[1 4] [2 5] [3 6]])
    (test:eq (list:zip [] []) []) })

  (test:case "zipLongest" {
    (test:eq (list:zipLongest [1 2] b nil) [[1 4] [2 5] [nil 6]])
    (test:eq (list:zipLongest a [4 5] nil) [[1 4] [2 5] [3 nil]])
    (test:eq (list:zipLongest [] [] nil) []) })

  (test:case "foldLeft" {
    (test:eq (list:foldLeft [] 0 (fun (x y) (+ x y))) 0)
    (test:eq (list:foldLeft ["1" "2" "3"] "" (fun (x y) (+ x y))) "123")
    (test:eq (list:foldLeft a 0 (fun (x y) (+ x y))) 6) })

  (test:case "zipWithIndex" {
    (test:eq (list:zipWithIndex a) [[0 1] [1 2] [2 3]])
    (test:eq (list:zipWithIndex []) []) })

  # lists weren't modified by any of the function calls
  (test:eq a [1 2 3])
  (test:eq b [4 5 6])

  (test:case "forAll, any, none" {
    (test:expect (list:forAll a (fun (e) (< e 4))))
    (test:expect (not (list:forAll a (fun (e) (< e 2)))))
    (test:expect (list:forAll [] (fun (e) (= e 2))))

    (test:expect (list:any a (fun (e) (< e 2))))
    (test:expect (not (list:any a (fun (e) (> e 8)))))
    (test:expect (not (list:any [] (fun (e) (= e 8)))))

    (test:expect (list:none a (fun (e) (> e 10))))
    (test:expect (not (list:none a (fun (e) (< e 2)))))
    (test:expect (list:none [] (fun (e) (= e 8))))
    (test:expect (list:none [4 5 6] (fun (e) (< e 3)))) })

  (test:case "countIf" {
    (test:eq (list:countIf a (fun (e) (= 0 (mod e 2)))) 1)
    (test:eq (list:countIf a (fun (e) (= 1 (mod e 2)))) 2)
    (test:eq (list:countIf [] (fun (e) (= 1 (mod e 2)))) 0) })

  (test:case "iterate" {
    (test:eq (list:iterate 0 (fun (x) (+ 1 x)) 5) [0 1 2 3 4])
    (test:eq (list:iterate 0 (fun (x) (+ 1 x)) 5) (list:iota 0 5))
    (test:eq (list:iterate "" (fun (x) (+ x "a")) 5) ["" "a" "aa" "aaa" "aaaa"])
    (test:eq (list:iterate 0 (fun (x) (+ 1 x)) 1) [0]) })

  (test:case "chunkBy" {
    (test:eq (list:chunkBy [1 2] 1) [[1] [2]])
    (test:eq (list:chunkBy [1 2 3] 3) [[1 2 3]])
    (test:eq (list:chunkBy [1 2 3 4] 3) [[1 2 3] [4]])
    (test:eq (list:chunkBy [1 2 3 4 5] 3) [[1 2 3] [4 5]])
    (test:eq (list:chunkBy [1 2 3 4 5 6] 3) [[1 2 3] [4 5 6]]) })

  (test:case "insert" {
    (test:eq (list:insert [0] 1 4) [0 4])
    (test:eq (list:insert [0] 0 4) [4 0])
    (test:eq (list:insert [0 9] 0 4) [4 0 9])
    (test:eq (list:insert [0 9] 1 4) [0 4 9])
    (test:eq (list:insert [0] 1 [1 2]) [0 1 2])
    (test:eq (list:insert [0] 0 [1 2]) [1 2 0])
    (test:eq (list:insert [0 9] 0 [1 2]) [1 2 0 9])
    (test:eq (list:insert [0 9] 1 [1 2]) [0 1 2 9]) })

  (test:case "window" {
    (list:window [] 1 (fun (l) (test:expect false)))
    (mut i 1)
    (list:window [1 2 3 4] 2
      (fun (l) {
        (test:eq (@ l 0) i)
        (test:eq (@ l 1) (+ 1 i))
        (set i (+ 1 i))
        (test:eq 2 (len l)) }))
    (test:eq i 4) })

  (test:case "transpose" {
    (test:eq (list:transpose [[1 2 3] [4 5 6] [7 8 9]]) [[1 4 7] [2 5 8] [3 6 9]])
    (let data ["123 328  51" " 45 64  387"])
    (test:eq (list:transpose data) [["1" " "] ["2" "4"] ["3" "5"] [" " " "] ["3" "6"] ["2" "4"] ["8" " "] [" " " "] [" " "3"] ["5" "8"] ["1" "7"]])
    (test:eq (list:transpose (list:transpose zipped)) zipped)
    (test:eq (list:transpose [[]]) [])
    (test:eq (list:transpose [[1]]) [[1]]) })

  (test:case "unique" {
    (test:eq (list:unique []) [])
    (test:eq (list:unique [1 1 1 1]) [1])
    (test:eq (list:unique [1 -1 1 -1]) [1 -1])
    (test:eq (list:unique ["a" "b" "a" "b" "c" "d"]) ["a" "b" "c" "d"]) }) })

