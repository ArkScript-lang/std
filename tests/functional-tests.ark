(import std.Functional:*)
(import std.Testing)
(import std.List)

(let foo (fun (x) (+ x 3)))
(let egg (fun (y) (* y 2)))
(let bar (fun (x y) (- x y)))

(test:suite functional {
  (test:case "compose" {
    (test:eq ((compose foo egg) 5) (foo (egg 5)))
    (test:eq ((compose egg egg) 5) (egg (egg 5))) })

  (test:case "left & right" {
    (let err (left 5))
    (err
      (fun (x) (test:expect true "err is left"))
      (fun (x) (test:expect false "err is left")))

    (let ok (right 6))
    (ok
      (fun (x) (test:expect false "ok is right"))
      (fun (x) (test:expect true "ok is right"))) })

  (test:case "flip" {
    (test:eq ((flip bar) 5 6) (bar 6 5))
    (test:eq ((flip bar) 6 5) (bar 5 6)) })

  (test:case "identity" {
    (test:eq (identity nil) nil)
    (test:eq (identity []) [])
    (test:eq (identity "hello") "hello") })

  (test:case "recombine" {
    (let mean (recombine
      (fun (a b) (/ a b))
      list:sum
      list:size))
    (test:eq (mean [0 1 1 2 3 5 8 13]) 4.125)
    (test:eq (mean [0]) 0)

    (let minMax (recombine
      (fun (a b) [a b])
      list:min
      list:max))
    (test:eq (minMax [1 1 2 3 5 8 13]) [1 13]) })})

